#!/usr/bin/env python
#    Copyright 2013-2016 ARM Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

"""
This module downloads external workload dependencies used by Workload Automation.
Works by first downloading a directory index of the assets, then iterating through
it to get assets for the specified workloads.
"""
import sys
import argparse
import logging

from requests import ConnectionError, RequestException

from wlauto import Workload, ResourceGetter, File, ExtensionLoader, Command, settings
from wlauto.resource_getters.standard import HttpGetter
from wlauto.utils.log import init_logging


__version__ = '0.2.0'

logger = logging.getLogger('get_assets')


class RemoteHttpGetter(HttpGetter):
    def __init__(self, base_url, force_download, **kwargs):
        super(RemoteHttpGetter, self).__init__(None, **kwargs)
        self.url = base_url
        self.always_fetch = force_download


class NamedWorkload(Workload):
    def __init__(self, name, **kwargs):
        super(NamedWorkload, self).__init__(None, **kwargs)
        self.name = name


def _instantiate(cls, *args, **kwargs):
    return cls(*args, **kwargs)


def exit_with_error(code=1, message='An error occurred. Exiting...'):
    logger.error(message)
    sys.exit(code)


def main(args):
    log_level = 1 if args.verbose else 0
    init_logging(log_level)
    logger.debug('Program arguments: {}'.format(vars(args)))
    if args.force:
        logger.info('Force-download of assets requested')
    if not args.url:
        logger.debug('URL not provided, falling back to `external_assets_url` setting in config.py')

    # Check workload arguments
    assets_to_get = args.all or args.workloads
    if not assets_to_get:
        exit_with_error(message='No workloads specified. Provide at least one, or use --all to get them all')

    # Check URL argument
    assets_repo = args.url or settings.external_assets_url
    if not assets_repo:
        message = 'No URL specified and `external_assets_url` config setting is empty.'
        if args.url:
            message = 'Provided assets URL is invalid or empty.'
        exit_with_error(message=message)

    # Get file index of assets
    logger.info('Downloading external assets from {}'.format(assets_repo))
    getter = _instantiate(RemoteHttpGetter, assets_repo, args.force)
    try:
        getter.index = getter.fetch_index()
    except (ConnectionError, RequestException) as e:
        exit_with_error(message=str(e))
    all_assets = dict()
    for k, v in getter.index.iteritems():
        all_assets[str(k)] = [str(asset['path']) for asset in v]

    # Filter requested workloads
    if args.all:
        assets_to_get = set(all_assets)
    else:
        assets_to_get = set(all_assets).intersection(args.workloads)
        if not assets_to_get:
            exit_with_error(message='Index does not contain assets for workloads: {}'.format(', '.join(args.workloads)))

    # Download the files
    for workload in assets_to_get:
        owner = _instantiate(NamedWorkload, workload)
        logger.info('Getting assets for: {}'.format(workload))
        for asset in all_assets[workload]:
            getter.get(File(owner, asset))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='''
        Download assets for the specified workloads from a remote server (currently a GitHub repo).''')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('-f', '--force', action='store_true',
                        help='Always fetch the assets, even if matching versions exist in local cache.')
    parser.add_argument('--url', metavar='URL',
                        help='''The location from which to download the files. If not provided,
                        config setting `external_assets_url` will be used instead.''')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-a', '--all', action='store_true',
                        help='Download assets for all workloads found in the index. Cannot be used with -w.')
    group.add_argument('-w', dest='workloads', metavar='WORKLOAD', nargs='+',
                        help='One or more workloads whose assets to download. Cannot be used with --all.')
    sys.exit(main(parser.parse_args()))
